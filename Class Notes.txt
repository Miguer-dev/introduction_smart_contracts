*https://docs.soliditylang.org/

-------------------------------------------------------------------Contract-------------------------------------------------------

// SPDX-License-Identifier: GPL-3.0
pragma solidity <version>;  //Ej >=0.7.0 <9.0.0

contract <name>
  
  //doSomething

  constructor() {
    // Código de inicialización
  }

  //doSomething
}


*https://spdx.org/licenses/

-------------------------------------------------------------------Variables------------------------------------------------------
Tipos de variables:
-bool: Verdadero o flaso
-string: Cadena de texto
-bytes<8-256>: Cadena de bytes
-uint<8-256>: enteros no negativos / int<8-256>: enteros pueden negativos. Pueden opcionalmente indicar su tamaño en bits.
-address / address payable: para que una dirección pueda recibir Ether. Guarda direcciones de ETH de 160 bits (20 bytes).

address(0) = "0x0000000000000000000000000000000000000000" se utiliza en Solidity para representar la dirección nula o cero, 
ya sea para inicializar variables de dirección o realizar comprobaciones en el contrato.


Variables globales:
-block: Información del bloque actual de la transacción.
-msg: Información de la llamada.
-tx: Información de la transacción.


Propiedades más comunes:
-block.gaslimit: Límite de gas en el bloque actual
-msg.data: Información de la llamada
-msg.sender: Dirección de la llamada
-msg.value: Número de wei enviado
-tx.gasprice: Costo de gas de la transacción


Access Modifier:
-public: default funciones,pueden ser accedidas tanto por fuera como por dentro del contrato.
-private: solo podrán ser accedidas desde adentro del propio contrato.
-internal: default variables, solo pueden ser accedidas por el mismo contrato o un contrato que deriva del mismo, contratos heredados.
-external: solo puede ser accedidas desde llamadas de otros contratos. No puede leerse dentro del mismo contrato.


Data Location: (string, array, struct y mapping)
-storage: memoria persistente, será guardada dentro de la Blockchain. Es el más COSTOSO. Similar a la memoria ROM
-memory: variables temporales durante ejecución. Se asimila a la RAM
-calldata: son constantes definidas en el entorno de ejecución de una variable. No son modificables.. Es buena práctica usar calldata para reducir el consumo de gas.

*Las variables de estado del contrato son guardadas en el storage, mientras que los parámetros de una función son guardados en memory.

-------------------------------------------------------------------Funciones------------------------------------------------------
Estructura Funciones:
function <name>(<type> <parameter>..., [..., ]>) <access modifiers> <mutability modifiers> <user defined modifiers> <returns>(<type>) {
    <content>
}

function multiplication(int a, int b) returns(int) {
    return a * b;
}
function multiplication(int a, int b) returns(int product) {
    product = a * b;
}


Mutability Modifier:
-view: Funciones que solo leen y devuelven dato, no realizan ningún tipo de lógica. No consumen gas (getters)

    function saludar(int a, int b) public view returns(string) {
        return saludo;
    }

-pure: Funciones que siempre devuelven un valor de forma determinista. Realizan una tarea y devuelven siempre el mismo valor para una misma entrada. 
Pero no modifican el valor de ninguna variable, o sea, no cambian el estado del contrato.

    function multiplication(int a, int b) public pure returns(int) {
        return a * b;
    }

-payable: Funciones especiales capaces de enviar o recibir ETH.

    function sendETH(address payable receiver) public payable {
        receiver.transfer(msg.value);
    }

*View and Pure hacen que la función no cobre gas, y si se omite, se asume que es una función que escribe en el storage de la EVM

-------------------------------------------------------------------Modifiers------------------------------------------------------

Functions Modifiers:
Suelen ser la validación de datos o la restricción de acceso a una función.

    // Modificador para validar que la llamada la realiza el dueño del contrato
    modifier onlyOwner() {
        require(msg.sender == owner, "No eres el owner");                      
        _;                                                         //indicarle al compilador de Solidity que continúe ejecutando el resto de la función si la condición se cumplió correctamente. Se puede poner donde se desee.
    }

    modifier onlyOwner2() {
        if(msg.sender != owner)
            revert("No eres el owner");                                       
        _;                                                                 
    }

    // Solo el dueño del proyecto puede cambiar al mismo
    function changeOwner(address _newOwner) public onlyOwner {
        owner = _newOwner;
    }

*Las operaciones en Solidity son atómicas, lo que quiere decir que se ejecuta correctamente cada una de las instrucciones o no se ejecuta ninguna.

-------------------------------------------------------------------Errores------------------------------------------------------
Manejo de errores
-assert: Se utiliza para pruebas, compara dos valores
-revert: Es un error que regresa todas las modificaciones de estado realizadas durante la ejecución de la función. Recibe por parámetro un mensaje de error.
Cualquier consumo de gas ejecutado hasta el momento de un revert se debe pagar
-require: Es una variación del revert que recibe por parámetro una expresión booleana y revierte si esta expresión es falsa.


error SendError(string message);

function doSomething() public {
    revert SendError("Mensaje del error");       
}

-------------------------------------------------------------------Eventos------------------------------------------------------

Events:
Se utilizan para notificar cambios realizados en un contrato. Deben ser recibidos por medio de aplicaciones Web3 que se encuentren observando el contrato.

event log(        //estructura del evento 
    address indexed sender, 
    string message
); 

function sendMessage() public {          
    emit log(msg.sender, "Este es el mensaje");      //disparar evento
}

*El modificador indexed está indicando que el argumento correspondiente al parámetro será indexado en el registro de eventos. 
Permitiendo que dicho valor se pueda utilizar como criterio de búsqueda
*Los eventos consumen GAS.

-------------------------------------------------------------------Struct------------------------------------------------------
struct <name> {
  <type> <name>;
  ...
  <type> <name>;
}


struct Persona {
    string nombre;
    string apellido;
    uint edad;
}

Persona p = Persona("Lionel", "Messi", 35);

p.nombre;     // Lionel
p.apellido;   // Messi
p.edad;       // 35

-------------------------------------------------------------------Array - Mapping------------------------------------------------------

Arrays: 
<type>[] <visibility> <name>;

//longitud fija
uint[3] numbers = [1, 2, 3];

//longitud dinámica
uint[] numbers;

numbers[1] //acceder a elemento

numbers.push(4)  //agrega elemento al final de array
numbers.pop()    //borra el ultimo elemento del array  
numbers.length   //longitud del array

*Los métodos push y pop solo funcionan en los arrays dinámicos.

Mapping:
mapping(<type> => <type>) <visibility> <name>;

mapping(address => uint) public balances;

mapping[direccion123] = 1000;
mapping[direccion456] = 2000;
mapping[direccion123] //1000

-------------------------------------------------------------------Enum------------------------------------------------------
enum <name> { <value1>, <value2>, ... , <value3>}

enum State { OPEN, PENDING, CLOSE} 
State currentState = State.PENDING;

*Los valores de los enum son una secuencia de enteros empezando por 0. (OPEN = 0, PENDING = 1, CLOSE = 2)

-------------------------------------------------------------------Gas------------------------------------------------------
El gas es una unidad de medida para el procesamiento de la EVM. Se mide en unidades de gas, y es constante para las mismas operaciones.

-gasPrice: Es la cantidad de ETH que pagamos por unidad de gas. Es decir, aunque el gas sea constante, la demanda por ese gas puede subir el precio.
-gasCost: Es la cantidad de unidades de gas que generó la ejecución

BASE_FEE = gasPrice * gasCost       //Este se quema
PRIORITY_FEE: Es el extra que se paga al minero por preferir tu transacción. Este sí va al minero.

Total = BASE_FEE + PRIORITY_FEE

-------------------------------------------------------------------Transferencias------------------------------------------------------
Funciones enviar:
-send: Envía un monto a una dirección y retorna false si la transferencia no se realiza
-transfer: Envía un monto y revierte si no se puede realizar
-call: Esta es más complicada, pero básicamente realiza una llamada hacia una dirección. Incluso se pueden llamar funciones de otro contrato si se le pasa 
un address válido y la llamada dentro del parámetro data. No obstante, al ser un mensaje, puede llevar ether, y por eso se usa para envíos. 
Retorna el resultado de la función llamada (si es que fué el caso)

*Send y transfer requieren address de tipo payable, tienen un limite de gas fijo .
*Call no tiene limite de gas por defecto, pero se puede configurar.


Funciones recibir:
-Receive: función opcional que se ejecuta cuando se recibe una transferencia de Ether sin parámetros. (es external obligatoriamente)
-Fallback: función opcional que se ejecuta cuando se recibe una transferencia de Ether con parámetros. (msg.data) 
-Función payable: se puede recibir Ether en una función si se le especifica el tipo payable.

Prioridad al recibir una transferencia:
                                                                    send Ether
                                                                        |
                                                                  hay parametros?                                                               
                                                                /                \
                                                              si                  no      
                                                             /                      \    
                     funcion con la firma especificada existe?                      receive() existe?               
                            /                             \                          /             \
                          si                              no                        no              si
                          /                                 \                      /                  \
             ejecuta la funcion                                 fallback existe?                    receive()
                                                                  /          \
                                                            fallback()      exception


-------------------------------------------------------------------Token ERC-20------------------------------------------------------
El estándar ERC-20 introduce tokens fungibles, es decir, tienen una propiedad que hace que cada token sea exactamente igual (en tipo y valor) que otro token.
Si un contrato inteligente implementa los siguientes métodos y eventos, se puede llamar un contrato de token ERC-20 y, una vez implementado, será responsable 
de realizar un seguimiento de los tokens creados en Ethereum:

Functions:
function name() public view returns (string)
function symbol() public view returns (string)
function decimals() public view returns (uint8)
function totalSupply() public view returns (uint256)
function balanceOf(address _owner) public view returns (uint256 balance)
function transfer(address _to, uint256 _value) public returns (bool success)
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)
function approve(address _spender, uint256 _value) public returns (bool success)
function allowance(address _owner, address _spender) public view returns (uint256 remaining)

Events:
event Transfer(address indexed _from, address indexed _to, uint256 _value)
event Approval(address indexed _owner, address indexed _spender, uint256 _value)

*https://ethereum.org/en/developers/docs/standards/tokens/erc-20/
*https://eips.ethereum.org/EIPS/eip-20
*https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol

-------------------------------------------------------------------Token ERC-721------------------------------------------------------
El ERC-721 introduce un estándar para NFT(Non-Fungible Token), en otras palabras, este tipo de Token es único y puede tener un valor diferente a otro Token del mismo Smart Contract, 
tal vez debido a su antigüedad, rareza o incluso algo más como su visual.

Functions:
function balanceOf(address _owner) external view returns (uint256);
function ownerOf(uint256 _tokenId) external view returns (address);
function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;
function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;
function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
function approve(address _approved, uint256 _tokenId) external payable;
function setApprovalForAll(address _operator, bool _approved) external;
function getApproved(uint256 _tokenId) external view returns (address);
function isApprovedForAll(address _owner, address _operator) external view returns (bool);

Events:
event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

*https://ethereum.org/en/developers/docs/standards/tokens/erc-721/
*https://eips.ethereum.org/EIPS/eip-721
*https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol