-------------------------------------------------------------------Variables------------------------------------------------------
Tipos de variables:
-bool
-string
-uint (enteros no negativos) / int (enteros pueden negativos).
-address / address payable (Para que una dirección pueda recibir Ether).


Variables globales:
-block: Información del bloque actual de la transacción.
-msg: Información de la llamada.
-tx: Información de la transacción.


Propiedades más comunes:
-block.gaslimit: Límite de gas en el bloque actual
-msg.data: Información de la llamada
-msg.sender: Dirección de la llamada
-msg.value: Número de wei enviado
-tx.gasprice: Costo de gas de la transacción


Visibilidad:
-public: default funciones,pueden ser accedidas tanto por fuera como por dentro del contrato.
-private: solo podrán ser accedidas desde adentro del propio contrato.
-internal: default variables, solo pueden ser accedidas por el mismo contrato o un contrato que deriva del mismo, contratos heredados.
-external: solo puede ser accedidas desde llamadas de otros contratos. No puede leerse dentro del mismo contrato.


Data Location: (string, array, struct y mapping)
-storage: memoria persistente, será guardada dentro de la Blockchain.
-memory: solo pueden ser usadas mientras se llama a una función. Después de esto, la misma se borrará. Puede modificarse mientras está en uso.
-calldata: similar a memory, pero no se pueden modificar mientras estén en uso. Es buena práctica usar calldata para reducir el consumo de gas.

*Las variables de estado del contrato son guardadas en el storage, mientras que los parámetros de una función son guardados en memory.

-------------------------------------------------------------------Funciones------------------------------------------------------
Estructura Funciones:
function multiplication(int a, int b) returns(int) {
    return a * b;
}
function multiplication(int a, int b) returns(int product) {
    product = a * b;
}


Tipos:
-view: Funciones que solo leen y devuelven dato, no realizan ningún tipo de lógica. No consumen gas (getters)

function saludar(int a, int b) public view returns(string) {
        return saludo;
    }

-pure: Funciones que siempre devuelven un valor de forma determinista. Realizan una tarea y devuelven siempre el mismo valor para una misma entrada. 
Pero no modifican el valor de ninguna variable, o sea, no cambian el estado del contrato.

function multiplication(int a, int b) public pure returns(int) {
        return a * b;
    }

-payable: Funciones especiales capaces de enviar o recibir ETH.

function sendETH(address payable receiver) public payable {
        receiver.transfer(msg.value);
    }


Functions Modifiers:
Suelen ser la validación de datos o la restricción de acceso a una función.

    // Modificador para validar que la llamada la realiza el dueño del contrato
    modifier onlyOwner() {
        require(msg.sender == owner, "No eres el owner");                       //en caso la condición no se cumpla, el require realizará un revert para volver atrás todos los cambios de estado del contrato por nosotros
        _;                                                                      //indicarle al compilador de Solidity que continúe ejecutando el resto de la función si la condición se cumplió correctamente.
    }

    // Solo el dueño del proyecto puede cambiar al mismo
    function changeOwner(address _newOwner) public onlyOwner {
        owner = _newOwner;
    }

*Las operaciones en Solidity son atómicas, lo que quiere decir que se ejecuta correctamente cada una de las instrucciones o no se ejecuta ninguna.

-------------------------------------------------------------------Eventos y Errores------------------------------------------------------

Events:
Se utilizan para notificar cambios realizados en un contrato. Deben ser recibidos por medio de aplicaciones Web3 que se encuentren observando el contrato.

event log(        //estructura del evento 
    address indexed sender, 
    string message
); 

function sendMessage() public {          
    emit log(msg.sender, "Este es el mensaje");      //disparar evento
}

*El modificador indexed está indicando que el argumento correspondiente al parámetro será indexado en el registro de eventos. 
Permitiendo que dicho valor se pueda utilizar como criterio de búsqueda

Errors:
Función es similar a la de los eventos, con la diferencia de que estos pueden revertir los cambios de estado hecho.

error SendError(string message);

function doSomething() public {
    revert SendError("Mensaje del error");
}

-------------------------------------------------------------------Struct------------------------------------------------------

struct Persona {
    string nombre;
    string apellido;
    uint edad;
}

Persona p = Persona("Lionel", "Messi", 35);

p.nombre;     // Lionel
p.apellido;   // Messi
p.edad;       // 35

-------------------------------------------------------------------Array - Mapping------------------------------------------------------

Arrays:

//longitud fija
uint[3] numbers = [1, 2, 3];

//longitud dinámica
uint[] numbers;

numbers[1] //acceder a elemento

numbers.push(4)  //agrega elemento al final de array
numbers.pop()    //borra el ultimo elemento del array  
numbers.length   //longitud del array

*Los métodos push y pop solo funcionan en los arrays dinámicos.

Mapping:

mapping(address => uint) public balances;

mapping[direccion123] = 1000;
mapping[direccion456] = 2000;
mapping[direccion123] //1000

-------------------------------------------------------------------Token ERC-20------------------------------------------------------
El estándar ERC-20 introduce tokens fungibles, es decir, tienen una propiedad que hace que cada token sea exactamente igual (en tipo y valor) que otro token.
Si un contrato inteligente implementa los siguientes métodos y eventos, se puede llamar un contrato de token ERC-20 y, una vez implementado, será responsable 
de realizar un seguimiento de los tokens creados en Ethereum:

Functions:
function name() public view returns (string)
function symbol() public view returns (string)
function decimals() public view returns (uint8)
function totalSupply() public view returns (uint256)
function balanceOf(address _owner) public view returns (uint256 balance)
function transfer(address _to, uint256 _value) public returns (bool success)
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)
function approve(address _spender, uint256 _value) public returns (bool success)
function allowance(address _owner, address _spender) public view returns (uint256 remaining)

Events:
event Transfer(address indexed _from, address indexed _to, uint256 _value)
event Approval(address indexed _owner, address indexed _spender, uint256 _value)

*https://ethereum.org/en/developers/docs/standards/tokens/erc-20/
*https://eips.ethereum.org/EIPS/eip-20
*https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol