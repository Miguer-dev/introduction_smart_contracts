*https://docs.soliditylang.org/


-------------------------------------------------------------------Contract-------------------------------------------------------

// SPDX-License-Identifier: GPL-3.0
pragma solidity <version>;  //Ej >=0.7.0 <9.0.0

contract <name>
  
  //doSomething

  constructor() {
    // Código de inicialización
  }

  //doSomething
}


*https://spdx.org/licenses/

-------------------------------------------------------------------Variables------------------------------------------------------
Tipos de variables:
-bool: Verdadero o flaso
-string: Cadena de texto
-bytes<8-256>: Cadena de bytes
-uint<8-256>: enteros no negativos / int<8-256>: enteros pueden negativos. Pueden opcionalmente indicar su tamaño en bits.
-address / address payable: para que una dirección pueda recibir Ether. Guarda direcciones de ETH de 160 bits (20 bytes).

address(0) = "0x0000000000000000000000000000000000000000" se utiliza en Solidity para representar la dirección nula o cero, 
ya sea para inicializar variables de dirección o realizar comprobaciones en el contrato.


Variables globales:
-block: Información del bloque actual de la transacción.
-msg: Información de la llamada.
-tx: Información de la transacción.


Propiedades más comunes:
-block.gaslimit: Límite de gas en el bloque actual
-msg.data: Información de la llamada
-msg.sender: Dirección de la llamada
-msg.value: Número de wei enviado
-tx.gasprice: Costo de gas de la transacción


Visibilidad:
-public: default funciones,pueden ser accedidas tanto por fuera como por dentro del contrato.
-private: solo podrán ser accedidas desde adentro del propio contrato.
-internal: default variables, solo pueden ser accedidas por el mismo contrato o un contrato que deriva del mismo, contratos heredados.
-external: solo puede ser accedidas desde llamadas de otros contratos. No puede leerse dentro del mismo contrato.


Data Location: (string, array, struct y mapping)
-storage: memoria persistente, será guardada dentro de la Blockchain.
-memory: solo pueden ser usadas mientras se llama a una función. Después de esto, la misma se borrará. Puede modificarse mientras está en uso.
-calldata: similar a memory, pero no se pueden modificar mientras estén en uso. Es buena práctica usar calldata para reducir el consumo de gas.

*Las variables de estado del contrato son guardadas en el storage, mientras que los parámetros de una función son guardados en memory.

-------------------------------------------------------------------Funciones------------------------------------------------------
Estructura Funciones:
function multiplication(int a, int b) returns(int) {
    return a * b;
}
function multiplication(int a, int b) returns(int product) {
    product = a * b;
}


Tipos:
-view: Funciones que solo leen y devuelven dato, no realizan ningún tipo de lógica. No consumen gas (getters)

function saludar(int a, int b) public view returns(string) {
        return saludo;
    }

-pure: Funciones que siempre devuelven un valor de forma determinista. Realizan una tarea y devuelven siempre el mismo valor para una misma entrada. 
Pero no modifican el valor de ninguna variable, o sea, no cambian el estado del contrato.

function multiplication(int a, int b) public pure returns(int) {
        return a * b;
    }

-payable: Funciones especiales capaces de enviar o recibir ETH.

function sendETH(address payable receiver) public payable {
        receiver.transfer(msg.value);
    }


Functions Modifiers:
Suelen ser la validación de datos o la restricción de acceso a una función.

    // Modificador para validar que la llamada la realiza el dueño del contrato
    modifier onlyOwner() {
        require(msg.sender == owner, "No eres el owner");                       //en caso la condición no se cumpla, el require realizará un revert para volver atrás todos los cambios de estado del contrato por nosotros
        _;                                                                      //indicarle al compilador de Solidity que continúe ejecutando el resto de la función si la condición se cumplió correctamente.
    }

    // Solo el dueño del proyecto puede cambiar al mismo
    function changeOwner(address _newOwner) public onlyOwner {
        owner = _newOwner;
    }

*Las operaciones en Solidity son atómicas, lo que quiere decir que se ejecuta correctamente cada una de las instrucciones o no se ejecuta ninguna.

-------------------------------------------------------------------Eventos y Errores------------------------------------------------------

Events:
Se utilizan para notificar cambios realizados en un contrato. Deben ser recibidos por medio de aplicaciones Web3 que se encuentren observando el contrato.

event log(        //estructura del evento 
    address indexed sender, 
    string message
); 

function sendMessage() public {          
    emit log(msg.sender, "Este es el mensaje");      //disparar evento
}

*El modificador indexed está indicando que el argumento correspondiente al parámetro será indexado en el registro de eventos. 
Permitiendo que dicho valor se pueda utilizar como criterio de búsqueda

Errors:
Función es similar a la de los eventos, con la diferencia de que estos pueden revertir los cambios de estado hecho.

error SendError(string message);

function doSomething() public {
    revert SendError("Mensaje del error");
}

-------------------------------------------------------------------Struct------------------------------------------------------
struct <name> {
  <type> <name>;
  ...
  <type> <name>;
}


struct Persona {
    string nombre;
    string apellido;
    uint edad;
}

Persona p = Persona("Lionel", "Messi", 35);

p.nombre;     // Lionel
p.apellido;   // Messi
p.edad;       // 35

-------------------------------------------------------------------Array - Mapping------------------------------------------------------

Arrays: 
<type>[] <visibility> <name>;

//longitud fija
uint[3] numbers = [1, 2, 3];

//longitud dinámica
uint[] numbers;

numbers[1] //acceder a elemento

numbers.push(4)  //agrega elemento al final de array
numbers.pop()    //borra el ultimo elemento del array  
numbers.length   //longitud del array

*Los métodos push y pop solo funcionan en los arrays dinámicos.

Mapping:
mapping(<type> => <type>) <visibility> <name>;

mapping(address => uint) public balances;

mapping[direccion123] = 1000;
mapping[direccion456] = 2000;
mapping[direccion123] //1000

-------------------------------------------------------------------Token ERC-20------------------------------------------------------
El estándar ERC-20 introduce tokens fungibles, es decir, tienen una propiedad que hace que cada token sea exactamente igual (en tipo y valor) que otro token.
Si un contrato inteligente implementa los siguientes métodos y eventos, se puede llamar un contrato de token ERC-20 y, una vez implementado, será responsable 
de realizar un seguimiento de los tokens creados en Ethereum:

Functions:
function name() public view returns (string)
function symbol() public view returns (string)
function decimals() public view returns (uint8)
function totalSupply() public view returns (uint256)
function balanceOf(address _owner) public view returns (uint256 balance)
function transfer(address _to, uint256 _value) public returns (bool success)
function transferFrom(address _from, address _to, uint256 _value) public returns (bool success)
function approve(address _spender, uint256 _value) public returns (bool success)
function allowance(address _owner, address _spender) public view returns (uint256 remaining)

Events:
event Transfer(address indexed _from, address indexed _to, uint256 _value)
event Approval(address indexed _owner, address indexed _spender, uint256 _value)

*https://ethereum.org/en/developers/docs/standards/tokens/erc-20/
*https://eips.ethereum.org/EIPS/eip-20
*https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/ERC20.sol

-------------------------------------------------------------------Token ERC-721------------------------------------------------------
El ERC-721 introduce un estándar para NFT(Non-Fungible Token), en otras palabras, este tipo de Token es único y puede tener un valor diferente a otro Token del mismo Smart Contract, 
tal vez debido a su antigüedad, rareza o incluso algo más como su visual.

Functions:
function balanceOf(address _owner) external view returns (uint256);
function ownerOf(uint256 _tokenId) external view returns (address);
function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;
function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;
function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
function approve(address _approved, uint256 _tokenId) external payable;
function setApprovalForAll(address _operator, bool _approved) external;
function getApproved(uint256 _tokenId) external view returns (address);
function isApprovedForAll(address _owner, address _operator) external view returns (bool);

Events:
event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);
event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);
event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);

*https://ethereum.org/en/developers/docs/standards/tokens/erc-721/
*https://eips.ethereum.org/EIPS/eip-721
*https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC721/ERC721.sol